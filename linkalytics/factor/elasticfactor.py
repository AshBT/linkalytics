from . import factor
from elasticsearch import Elasticsearch
import json
import urllib3
from .. environment import cfg
import logging

es_log = logging.getLogger("elasticsearch")
es_log.setLevel(logging.CRITICAL)
urllib3_log = logging.getLogger("urllib3")
urllib3_log.setLevel(logging.CRITICAL)
urllib3.disable_warnings()


class ESFactor(factor.Factor):
    """
    ESFactor is a class to build exact match factors on the fly with Elastic Search. This includes: phone, e-mail, social media username, title, and text.
    """

    def __init__(self, name, url, size=500):
        super(ESFactor, self).__init__(name)
        self.size = size
        self.es = Elasticsearch(
                    [url],
                    port=443,
                    use_ssl=False,
                    verify_certs=False
                    )

    def lookup(self, ad_id):
        """
        Get data from ad_id
        :param ad_id: str
            String to be queried
        """
        payload = {
            "size": self.size,
            "query": {
                "ids": {
                    "values": [ad_id]
                }
            }
        }
        results = self.es.search(body=payload)
        field_vals = []
        for hit in results['hits']['hits']:
            if self.field in hit["_source"]:
                if isinstance(hit["_source"][self.field], list):
                    for item in hit["_source"][self.field]:
                        field_vals.append(item)
                else:
                    field_vals.append(hit["_source"][self.field])
        return field_vals

    def reverse_lookup(self, field_value):
        """
        Get ad_id from a specific field and search term
        :param field_value: str
            String to be queried
        """
        payload = {
                "size": self.size,
                "query": {
                    "match_phrase": {
                        self.field: field_value
                    }
                }
            }
        results = self.es.search(body=payload)
        if results['hits']['total']==0: #If the Elastic Search returns 0 results, then change the search field from self.field to all and search again. This solves the problem or poor indexing where a term like missblakebanks shows up in "_all" but not in "text"
            payload = {
                "size": self.size,
                "query": {
                    "match_phrase": {
                        "_all": field_value
                    }
                }
            }
            results = self.es.search(body=payload)
        ids = []
        for hit in results['hits']['hits']:
            ids.append(hit["_id"])
        return ids


def combine_two_factors(original, addition):
    """
    Union two dictionaries
    :param original: dict
        Dict to union
    :param addition: dict
        Dict to union
    """
    for k1 in addition:
        if k1 not in original:
            original[k1] = {}
        for k2 in addition[k1]:
            original[k1][k2] = addition[k1][k2]
    return original


def combine_multi_factors(factors):
    """
    Union multiple dictionaries
    :param factors: list of dicts
        List of dicts to union
    """
    original = factors[0]
    for i in factors[1:len(factors)]:
        if i:
            original = combine_two_factors(original, i)
    return original


def suggest(ad_id, factor_label, url):
    """
    :param ad_id: str
        Str of number
    :param factor_label: str
        Str to specify factor
    :param url: str
        Str for Elastic Search instance
    """
    try:
        factor = ESFactor(factor_label, url)
        suggestions = factor.suggest(ad_id)
        # print(factor_type, len(suggestions[ad_id][factor_type]))
        if len(suggestions[ad_id][factor_label]) == 0:
            return None
        else:
            return suggestions
    except TypeError:
        # print(factor_type, 0)
        return None


def factor_constructor(ad_id, factor_labels, url):
    """
    :param ad_id: str
        Str of number
    :param factor_labels: list of strings
        List of strings to specify factors
    :param url: str
        Str for Elastic Search instance
    """
    suggestions = []
    for i in factor_labels:
        suggestions.append(suggest(ad_id, i, url))
    combo = combine_multi_factors(suggestions)
    return combo


def flatten(data, level):
    """
    :param data: dict
        Dict of suggestions generated by the factor_constructor
    :param level: int
        Int for the maximum levels of recursion for flattening
    """
    results = set()

    def get_ad_ids(subdict, results, recursion):
        """
        :param subdict: dict
            Dict that gets iteratively smaller
        :param results: set
            Set containing the results
        :param recursion: int
            Int specifying the current recursion level
        """
        if level <= recursion:
            for k, v in subdict.items():
                for i in v:
                    results.add(i)
        else:
            for k, v in subdict.items():
                if isinstance(v, dict):
                    recursion = recursion + 1
                    get_ad_ids(v, results, recursion)
                else:
                    for i in v:
                        results.add(i)

    get_ad_ids(data, results, 0)
    return results


def prune(data, keepers):
    #Remove everything that doesn't contain the keepers
    # def visit(subdict):
    #     keep = []
    #     for k, v in subdict.items():
    #         for i in keepers:
    #             if i in v:
    #                 print(k[v])
    #                 keep.append(k[v])
    #             elif isinstance(v, dict):
    #                 visit(v)
    #             else:
    #                 pass
    #     return keep
    # keep = visit(data)
    # copy = data
    # for k1 in copy:
    #     for k2 in copy[k1]:
    #         if k2 not in keep:
    #             del data[k1][k2]
    #         try:
    #             for k3 in copy[k1][k2]:
    #                 if k3 not in keep.values():
    #                     del data[k1][k2][k3]
    #         except KeyError:
    #             pass
    return {}


def extend(data, url, factor_values, degree):
    """
    :param data: dict
        Dict of suggestions generated by the factor_constructor
    :param url: str
        Str for Elastic Search instance
    :param factor_values: List of strings
        List of strings to specify factors
    :param degree: Str
        String to specify the extension name
    """
    field_values = set()
    for v in data.values():
        for value in flatten(v, 1):
            field_values.add(value)
    data[degree] = {}
    ad_ids_2 = flatten(data, 10)
    for ad_id in ad_ids_2:
        addition = factor_constructor(ad_id,  factor_values, url)
        print(".")
        new_field_values = list(flatten(addition, 1))
        for value in new_field_values:
            if value in field_values:
                new_field_values.remove(value)
        print("new fields:", new_field_values)
        data[degree] = prune(addition, new_field_values)
    return data


def main():
    url = cfg["cdr_elastic_search"]["hosts"] + cfg["cdr_elastic_search"]["index"]
    ad_id = "63166071"
    # ad_id = "71046685"
    # ad_id = "31318107"
    # ad_id2 = "62442471"
    """
    Here's an example using the factors and the factor constructor
    """
    x = {}
    x["original"] = factor_constructor(ad_id, ["phone", "email", "text", "title"], url)
    print(json.dumps(x))

    # print(json.dumps(x))
    # print(flatten(x, 2))
    b = extend(x, url, ["phone", "email", "text", "title"], "ext2")
    print(json.dumps(b))
    # c = extend(b, url, "all", ["phone"], "ext3")
    # print(json.dumps(c))

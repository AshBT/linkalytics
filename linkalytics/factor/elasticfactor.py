from . import factor
from elasticsearch import Elasticsearch
import json
import urllib3
from .. environment import cfg
import logging

es_log = logging.getLogger("elasticsearch")
es_log.setLevel(logging.CRITICAL)
urllib3_log = logging.getLogger("urllib3")
urllib3_log.setLevel(logging.CRITICAL)
urllib3.disable_warnings()


class ESFactor(factor.Factor):
    """
    ESFactor is a class to build exact match factors on the fly with Elastic Search. This includes: phone, e-mail, social media username, title, and text.
    """

    def __init__(self, name, url, size=500):
        super(ESFactor, self).__init__(name)
        self.size = size
        self.es = Elasticsearch(
                    [url],
                    port=443,
                    use_ssl=False,
                    verify_certs=False
                    )

    def lookup(self, ad_id):
        """
        Get data from ad_id
        :param ad_id: str
            String to be queried
        """
        payload = {
            "size": self.size,
            "query": {
                "ids": {
                    "values": [ad_id]
                }
            }
        }
        results = self.es.search(body=payload)
        field_vals = []
        for hit in results['hits']['hits']:
            if self.field in hit["_source"]:
                if isinstance(hit["_source"][self.field], list):
                    for item in hit["_source"][self.field]:
                        field_vals.append(item)
                else:
                    field_vals.append(hit["_source"][self.field])
        return field_vals

    def reverse_lookup(self, field_value):
        """
        Get ad_id from a specific field and search term
        :param field_value: str
            String to be queried
        """
        payload = {
                "size": self.size,
                "query": {
                    "match_phrase": {
                        self.field: field_value
                    }
                }
            }
        results = self.es.search(body=payload)
        if results['hits']['total']==0: #If the Elastic Search returns 0 results, then change the search field from self.field to all and search again. This solves the problem or poor indexing where a term like missblakebanks shows up in "_all" but not in "text"
            payload = {
                "size": self.size,
                "query": {
                    "match_phrase": {
                        "_all": field_value
                    }
                }
            }
            results = self.es.search(body=payload)
        ids = []
        for hit in results['hits']['hits']:
            ids.append(hit["_id"])
        return ids


def combine_two_factors(original, addition):
    """
    Union two dictionaries
    :param original: dict
        Dict to union
    :param addition: dict
        Dict to union
    """
    for k1 in addition:
        if k1 not in original:
            original[k1] = {}
        for k2 in addition[k1]:
            original[k1][k2] = addition[k1][k2]
    return original


def combine_multi_factors(factors):
    """
    Union multiple dictionaries
    :param factors: list of dicts
        List of dicts to union
    """
    original = factors[0]
    for i in factors[1:len(factors)]:
        if i:
            original = combine_two_factors(original, i)
    return original


def suggest(ad_id, factor_label, url):
    """
    :param ad_id: str
        Str of number
    :param factor_label: str
        Str to specify factor
    :param url: str
        Str for Elastic Search instance
    """
    try:
        factor = ESFactor(factor_label, url)
        suggestions = factor.suggest(ad_id)
        # print(factor_type, len(suggestions[ad_id][factor_type]))
        if len(suggestions[ad_id][factor_label]) == 0:
            return None
        else:
            return suggestions
    except TypeError:
        # print(factor_type, 0)
        return None


def factor_constructor(ad_id, factor_labels, url):
    """
    :param ad_id: str
        Str of number
    :param factor_labels: list of strings
        List of strings to specify factors
    :param url: str
        Str for Elastic Search instance
    """
    suggestions = []
    for i in factor_labels:
        suggestions.append(suggest(ad_id, i, url))
    combo = combine_multi_factors(suggestions)
    return combo


def extend(data, url, field_value, factor_values, degree):
    """
    :param data: dict
        Dict of suggestions generated by the factor_constructor
    :param url: str
        Str for Elastic Search instance
    :param item: str
        Str for field_value to iterate on e.g. "5101234567" or "all" to specify all field values
    :param factor_values: List of strings
        List of strings to specify factors
    :param degree: Str
        String to specify the extension name
    """
    existing_data = set()
    for i in data:
        existing_data.add(i)
    print("************", "\n", existing_data)
    data[degree] = {}
    ad_ids_2 = set()
    for k1, v1 in data["original"].items():
        for k2, v2 in v1.items():
            if (k2 == field_value) or (field_value == "all"):
                for v3 in v2.values():
                    for i in v3:
                        ad_ids_2.add(i)
    for ad_id in ad_ids_2:
        addition = factor_constructor(ad_id, url, factor_values)
        print(".")
        try:
            for k1 in addition:
                if k1 not in data["original"]:
                    for k2 in addition[k1]:
                        for k3 in addition[k1][k2]:
                            for j in existing_data:
                                check = {}
                                for key in data[j].keys():
                                    try:
                                        if data[j][key][k2][k3]:
                                            check.add(1)
                                    except:
                                        pass
                            if len(check) == 0:
                                pass
                            else:
                                data[degree][k1] = {}
                                data[degree][k1][k2] = {}
                                data[degree][k1][k2][k3] = addition[k1][k2][k3]
        except TypeError:
            pass

    return data


def main():
    url = cfg["cdr_elastic_search"]["hosts"] + cfg["cdr_elastic_search"]["index"]
    ad_id = "63166071"
    # ad_id = "71046685"
    # ad_id = "31318107"
    # ad_id2 = "62442471"
    """
    Here's an example using the factors and the factor constructor
    """
    a = factor_constructor(ad_id, ["phone", "email", "text", "title"], url)
    x = {}
    x["original"] = a
    print(json.dumps(x))
    b = extend(x, url, "all", ["phone", "email", "text", "title"], "ext2")
    print(json.dumps(b))
    c = extend(b, url, "all", ["phone"], "ext3")
    print(json.dumps(c))

    ad_ids_extended = set()
    for k1 in b:
        for k2 in b[k1]:
            for k3 in b[k1][k2]:
                for k4 in b[k1][k2][k3]:
                    for k5 in b[k1][k2][k3][k4]:
                        ad_ids_extended.add(k5)
    print("____+_+____")
    print(ad_ids_extended)
